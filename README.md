# Compiler Project

A multi-stage compiler for a hypothetical programming language, built for educational purposes as part of an undergraduate compilers course. The project is organized into six distinct stages (`etapas`), each representing a key phase in the compilation process, from lexical analysis to final assembly code generation.

## Quick Start

These instructions will guide you through compiling and running one of the compiler stages.

### Prerequisites

Ensure you have the following tools installed on your system:
*   `make`
*   `flex`
*   `bison`
*   `gcc`

### Building and Running a Stage

1.  **Navigate to a stage directory.** Each stage is self-contained.
    ```bash
    cd etapa6
    ```

2.  **Compile the code using Make.** This will generate an executable for that stage (e.g., `etapa6`).
    ```bash
    make
    ```

3.  **Run the executable.** You will typically need to provide a source file for the compiler to process.
    ```bash
    ./etapa6 < test.txt
    ```

4.  **Clean up build files.**
    ```bash
    make clean
    ```

## Project Stages (Etapas)

The compiler is divided into six sequential stages:

### ðŸ“¦ `etapa1`: Lexical Analysis
This is the first phase of the compiler. It uses `flex` to perform lexical analysis, reading the source code and converting the stream of characters into a stream of tokens.

### ðŸ“¦ `etapa2`: Syntactic Analysis
This stage introduces a parser generated by `bison`. It takes the token stream from the lexical analyzer and verifies that it conforms to the grammatical rules of the source language, building a parse tree in the process.

### ðŸ“¦ `etapa3`: Abstract Syntax Tree (AST)
Building on the previous stage, an Abstract Syntax Tree (AST) is constructed. The AST is a hierarchical tree-like representation of the source code's structure, which is more suitable for the subsequent phases of compilation.

### ðŸ“¦ `etapa4`: Semantic Analysis
This stage traverses the AST to perform semantic checks. It ensures that the code is semantically correct, verifying things like type compatibility, variable declarations, and function call signatures.

### ðŸ“¦ `etapa5`: Intermediate Code Generation
After semantic validation, this stage generates an intermediate representation (IR) of the source code in the form of Three-Address Code (TACs). This IR is machine-independent and simplifies the final code generation phase.

### ðŸ“¦ `etapa6`: Assembly Code Generation
The final stage of the compiler. It takes the Three-Address Code and translates it into low-level assembly code for a target architecture.

## Contributing

If you have suggestions for improving the code or documentation, please feel free to open an issue or submit a pull request.
